In our design, instead of allowing the users to directly change password when they log in, we put the change password button on the login page. The reason of doing that is that when we are testing our web server, we found that the browser will cache the information of users if they don’t remove them deliberately. That is to say, if the user forgets to log out, the browser will keep the login status, so other people who use the same browser or ip will be able to directly get in the user’s account and change its password. The same thing can happen when attacker hijack the user’s cookie or session information. Therefore, the current design requires the user to have both the username and password to be able the change the password. SInce we will not leak the password of user anywhere in our server, we make sure the password is safe. So this approach can lower the possibility of being network hijacking by attackers.

To prevent SQL injection attack, we write our codes that operate the sqlite database securely so that the attackers cannot use ‘ -- to launch the SQL injection attack and steal the information from our database. For example, all the codes that operate the sqlite database has the form similar to this one, "cur.execute('SELECT id, password FROM `user` WHERE username=?', (username,))". To prevent Cross-site Scripting attack, we use the function escape, which returns a new string in which certain characters like “<>?=/” etc. have been replaced by a hexadecimal escape sequence. This function helps us turns a raw html script into a new string that cannot be invoked to launch the Cross-site Scripting attack. For example, "<script>alert(gg)</script>" becomes "&lt;script&gt;alert(gg)&lt;/script&gt;" after using escape. When we display it on the web page, it cannot be invoked. Moreover, we prohibit the users to create their usernames and their channels names using those special characters so that Cross-site Scripting Attack does not work at all.

We also hash the passwords of our users before entering them into the sqlite database in order to provide password safety. The password hashing is one way hashing using the combination of bcrypt and sha-256, so it is uncrackable by now. To have more security, we encrypt our chat messages of the channels using symmetric encryption. We encrypt each chat message before entering them into our database. When we display them in the channels on the web server, we decrypt the chat messages one by one.

In our chat server file upload and download, since the transfer of file is through raw socket between chat server and user, we feel like it is very vulnerable for the file to be hijack by attacker. Therefore, we decide to have extra layer of protection to make sure the completeness of file. The method we use to make sure the completeness of file is to send an MD5 code, which is generated by the file name with SHA256 algorithm, in each file to transfer with. Consequently,  when the chat server and client receive the file, they  are able to check the completeness of the file, preventing from receiving cracked file or being injected malicious content by attacker.
